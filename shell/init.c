/*
 * This file was generated by the mkinit program.
 */

#include "shell.h"
#include "mystring.h"
#include "init.h"
#include <stdio.h>
#include "input.h"
#include "error.h"
#include "output.h"
#include "memalloc.h"
#include "trap.h"
#include "parser.h"
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include "cd.h"
#include "var.h"



#undef  EOF_NLEFT
#define EOF_NLEFT -99		/* value of parsenleft when EOF pushed back */
#undef  IBUFSIZ
#define IBUFSIZ (BUFSIZ + 1)
#undef  OUTBUFSIZ
#define OUTBUFSIZ BUFSIZ
#undef  MEM_OUT
#define MEM_OUT -3		/* output to dynamically allocated memory */
#undef  S_DFL
#define S_DFL 1			/* default signal handling (SIG_DFL) */
#undef  S_CATCH
#define S_CATCH 2		/* signal is caught */
#undef  S_IGN
#define S_IGN 3			/* signal is ignored (SIG_IGN) */
#undef  S_HARD_IGN
#define S_HARD_IGN 4		/* signal is ignored permenantly */
#undef  S_RESET
#define S_RESET 5		/* temporary - to reset a hard ignored sig */
#undef  VTABSIZE
#define VTABSIZE 39



struct strpush {
	struct strpush *prev;	/* preceding string on stack */
	char *prevstring;
	int prevnleft;
	struct alias *ap;	/* if push was associated with an alias */
	char *string;		/* remember the string since it may change */
};

struct parsefile {
	struct parsefile *prev;	/* preceding file on stack */
	int linno;		/* current line */
	int fd;			/* file descriptor (or -1 if string) */
	int nleft;		/* number of chars left in this line */
	int lleft;		/* number of chars left in this buffer */
	char *nextc;		/* next char in buffer */
	char *buf;		/* input buffer */
	struct strpush *strpush; /* for pushing strings at this level */
	struct strpush basestrpush; /* so pushing one is fast */
};

extern int parselleft;		/* copy of parsefile->lleft */
extern struct parsefile basepf;	/* top level input file */
extern char basebuf[IBUFSIZ];	/* buffer for top level input file */

extern struct localvar_list *localvar_stack;
extern char **environ;



/*
 * Initialization code.
 */

void
init() {

      /* from input.c: */
      {
	      basepf.nextc = basepf.buf = basebuf;
      }

      /* from output.c: */
      {
#ifdef USE_GLIBC_STDIO
	      initstreams();
#endif
      }

      /* from trap.c: */
      {
	      sigmode[SIGCHLD - 1] = S_DFL;
	      setsignal(SIGCHLD);
      }

      /* from var.c: */
      {
	      char **envp;
	      static char ppid[32] = "PPID=";
	      const char *p;
	      struct stat st1, st2;

	      initvar();
	      for (envp = environ ; *envp ; envp++) {
		      p = endofname(*envp);
		      if (p != *envp && *p == '=') {
			      setvareq(*envp, VEXPORT|VTEXTFIXED);
		      }
	      }

	      setvarint("OPTIND", 1, 0);

	      fmtstr(ppid + 5, sizeof(ppid) - 5, "%ld", (long) getppid());
	      setvareq(ppid, VTEXTFIXED);

	      p = lookupvar("PWD");
	      if (p)
		      if (*p != '/' || stat(p, &st1) || stat(".", &st2) ||
			  st1.st_dev != st2.st_dev || st1.st_ino != st2.st_ino)
			      p = 0;
	      setpwd(p, 0);
      }
}



/*
 * This routine is called when an error or an interrupt occurs in an
 * interactive shell and control is returned to the main command loop.
 */

void
reset() {

      /* from input.c: */
      {
	      parselleft = parsenleft = 0;	/* clear input buffer */
	      popallfiles();
      }

      /* from output.c: */
      {
#ifdef notyet
	      out1 = &output;
	      out2 = &errout;
#ifdef USE_GLIBC_STDIO
	      if (memout.stream != NULL)
		      __closememout();
#endif
	      if (memout.buf != NULL) {
		      ckfree(memout.buf);
		      memout.buf = NULL;
	      }
#endif
      }

      /* from var.c: */
      {
	      unwindlocalvars(0);
      }
}
